# Теоретическая часть 

## Условие задачи

**Преобразование Барроуза — Уилера** (англ. *Burrows-Wheeler transform*)
— алгоритм, используемый для предварительной обработки данных перед
сжатием, разработанный для улучшения эффективности последующего кодирования.
Преобразование Барроуза — Уилера меняет порядок символов во входной
строке таким образом, что повторяющиеся подстроки образуют на выходе
идущие подряд последовательности одинаковых символов.

`bzip2` использует преобразование Барроуза — Уилера для превращения
последовательностей многократно чередующихся символов в строки
одинаковых символов, затем применяет преобразование MTF, и в конце кодирование Хаффмана.

## Подходы к решению задачи

### Формальная постановка задачи

Реализовать `bzip2` или написать аналогичную
утилиту для сжатия данных с использованием преобразования Барроуза — Уилера.

### Прямой алгоритм преобразования Барроуза — Уилера
**Вход:** строка для кодирования  
**Выход:** закодированная строка, ее номер в таблице циклических сдвигов

1. Составляется таблица всех циклических сдвигов входной строки.
2. Производится лексикографическая (в алфавитном порядке) сортировка строк таблицы.
3. В качестве выходной строки выбирается последний столбец таблицы
   преобразования и номер строки, совпадающей с исходной.

**Достоинства:** работает довольно быстро — временная сложность данного 
алгоритма `O(NlogN)` (из-за сортировки), пространственная `O(N)`  
**Недостатки:** нет

### Наивный обратный алгоритм преобразования Барроуза — Уилера
**Вход:** закодированная строка, ее номер `k` в таблице циклических сдвигов  
**Выход:** раскодированная строка
1. Для получения таблицы циклических сдвигов создаются `n` строк
   (`n` - количество символов во входной строке). В `i`-ую строку
   записывается `i`-ый символ входной строки. Полученные строки сортируются по
   возрастанию в лексикографическом порядке.
2. К `i`-ой строке слева (в качестве первого символа строки) приписывается `i`-ый символ
   входной строки, после чего строки снова сортируются. Операция выполняется до тех пор,
   пока в каждой из строк таблицы не окажется `n` символов.
3. В полученной таблице выбираем строку с номером `k`. Это и есть искомая строка.

**Достоинства:** работает  
**Недостатки:** очень долго и дорого — временная сложность данного алгоритма `O(N^3*logN)`, пространственная `O(N^2)`

### Улучшенный обратный алгоритм преобразования Барроуза — Уилера

**Вход:** закодированная строка `last`, ее номер `k` в таблице циклических сдвигов  
**Выход:** раскодированная строка

1. Для получения первого столбца матрицы циклических сдвигов символы 
закодированной строки сортируются в лексикографическом порядке. Получается объект `first`.
2. Формируется взаимно однозначное соответствие между элементами объекта `first` и элементами объекта `last`
3. Формируется выходная строка

**Достоинства:** работает быстрее наивного алгоритма — временная сложность данного 
алгоритма `O(NlogN)` (из-за сортировки), пространственная `O(N)`  
**Недостатки:** сложно придумать, как реализовать соответствие (п. 2)

### Оптимизированный обратный алгоритм преобразования Барроуза — Уилера

Если размер алфавита не очень большой, то для выяснения первого столбца матрицы можно использовать сортировку подсчетом,
в этом случае алгоритм работает за `O(N+M)` действий и требует `O(N+M)` памяти, где M — размер алфавита

**Достоинства:** работает быстрее улучшенного алгоритма — временная сложность данного алгоритма `O(N+M)`, пространственная `O(N+M)`  
**Недостатки:** актуален при небольшом алфавите

## Выбор алгоритма

В текущей реализации используется прямой алгоритм и улучшенный обратный алгоритм преобразования Барроуза — Уилера, 
поскольку (пока) длина входных данных меньше размера алфавита.
