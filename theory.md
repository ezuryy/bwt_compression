# Теоретическая часть 

## Условие задачи

**Преобразование Барроуза — Уилера** (англ. *Burrows-Wheeler transform*)
— алгоритм, используемый для предварительной обработки данных перед
сжатием, разработанный для улучшения эффективности последующего кодирования.
Преобразование Барроуза — Уилера меняет порядок символов во входной
строке таким образом, что повторяющиеся подстроки образуют на выходе
идущие подряд последовательности одинаковых символов.

BWT не сжимает данные, но преобразует блок данных в формат, исключительно подходящий для компрессии.

Прежде всего, следует отметить одну из его особенностей. BWT оперирует сразу целым блоком данных. 
То есть, ему заранее известны сразу все элементы входного потока или, по крайней мере, достаточно большого блока. 
Это делает затруднительным использование алгоритма в тех областях применения, где требуется сжатие данных “на лету”, 
символ за символом.

Преобразование Барроуза — Уилера используется вместе со следующими методами:

- кодирование длин повторов (RLE);
- метод перемещения стопки книг (MTF);
- кодирование расстояний (DC);
- метод Хаффмана;
- арифметическое кодирование.

Следует отметить еще одно преобразование, основанное на сортировке блока данных – преобразование Шиндлера (ST). 
ST является не разновидностью преобразования Барроуза-Уилера, а скорее его обобщением.  

BWT и ST используются в следующих архиваторах (`компрессор` версия): `Imp` 1.12 (метод 2), `X1` 0.95 (метод 7), `SZip` 1.12, `BWC` 0.99, `BZip` 0.21, 
`BZip2` 1.0.1, `Bred`, `Bred2`, `Bred3`, `BA` 1.01br5, `ZZip` 0.36c, `DC` 0.99, `ERI` 4.17, `SBC` 0.850b, `YBS` 0.03e.

## Подходы к решению задачи

### Формальная постановка задачи

Реализовать утилиту для сжатия текстовых данных с использованием преобразования Барроуза — Уилера с коэффициентом сжатия   
`k = size_of_input_file / size_of_compressed_file`  
порядка 1,5.

### 1. BWT (Burrows-Wheeler Transform)

#### Прямой алгоритм преобразования Барроуза — Уилера
**Вход:** строка для кодирования  
**Выход:** закодированная строка, ее номер в таблице циклических сдвигов

1. Составляется таблица всех циклических сдвигов входной строки.
2. Производится лексикографическая (в алфавитном порядке) сортировка строк таблицы.
3. В качестве выходной строки выбирается последний столбец таблицы
   преобразования и номер строки, совпадающей с исходной.

**Достоинства:** работает довольно быстро — временная сложность данного 
алгоритма `O(NlogN)` (из-за сортировки), пространственная `O(N)`  
**Недостатки:** нет

#### Наивный обратный алгоритм преобразования Барроуза — Уилера
**Вход:** закодированная строка, ее номер `k` в таблице циклических сдвигов  
**Выход:** раскодированная строка
1. Для получения таблицы циклических сдвигов создаются `n` строк
   (`n` - количество символов во входной строке). В `i`-ую строку
   записывается `i`-ый символ входной строки. Полученные строки сортируются по
   возрастанию в лексикографическом порядке.
2. К `i`-ой строке слева (в качестве первого символа строки) приписывается `i`-ый символ
   входной строки, после чего строки снова сортируются. Операция выполняется до тех пор,
   пока в каждой из строк таблицы не окажется `n` символов.
3. В полученной таблице выбираем строку с номером `k`. Это и есть искомая строка.

**Достоинства:** работает  
**Недостатки:** очень долго и дорого — временная сложность данного алгоритма `O(N^3*logN)`, пространственная `O(N^2)`

#### Улучшенный обратный алгоритм преобразования Барроуза — Уилера

**Вход:** закодированная строка `last`, ее номер `k` в таблице циклических сдвигов  
**Выход:** раскодированная строка

1. Для получения первого столбца матрицы циклических сдвигов символы 
закодированной строки сортируются в лексикографическом порядке. Получается объект `first`.
2. Формируется взаимно однозначное соответствие между элементами объекта `first` и элементами объекта `last`
3. Формируется выходная строка

**Достоинства:** работает быстрее наивного алгоритма — временная сложность данного 
алгоритма `O(NlogN)` (из-за сортировки), пространственная `O(N)`  
**Недостатки:** сложно придумать, как реализовать соответствие (п. 2)

#### Оптимизированный обратный алгоритм преобразования Барроуза — Уилера

Если размер алфавита не очень большой, то для выяснения первого столбца матрицы можно использовать сортировку подсчетом,
в этом случае алгоритм работает за `O(N+M)` действий и требует `O(N+M)` памяти, где M — размер алфавита

**Достоинства:** работает быстрее улучшенного алгоритма — временная сложность данного алгоритма `O(N+M)`, пространственная `O(N+M)`  
**Недостатки:** актуален при небольшом алфавите

### 2. LZW (Lempel—Ziv—Welch)

#### Кодирование алгоритмом Лемпеля — Зива — Велча

LZW-сжатие заменяет строки символов некоторыми кодами. Это делается без какого-либо анализа входного текста. Вместо этого 
при добавлении каждой новой строки символов просматривается таблица строк. Сжатие происходит, когда код заменяет строку 
символов. Коды, генерируемые LZW-алгоритмом, могут быть любой длины, но они должны содержать больше бит, чем единичный 
символ. Первые 256 кодов по умолчанию соответствуют стандартному набору символов. 
Остальные коды соответствуют обрабатываемым алгоритмом строкам.

**Пример**  
Нужно закодировать строку `abacabadabacabae`
```
|   Index    |   Output   |   Entry   |
|------------|------------|-----------|
|     0      |      -     |     a     |
|     1      |      -     |     b     |
|     2      |      -     |     c     |
|     3      |      -     |     d     |
|     4      |      -     |     e     |
|     5      |      0     |     ab    |
|     6      |      1     |     ba    |
|     7      |      0     |     ac    |
|     8      |      2     |     ca    |
|     9      |      5     |     aba   |
|     10     |      0     |     ad    |
|     11     |      3     |     da    |
|     12     |      9     |     abac  |
|     13     |      8     |     cab   |
|     14     |      6     |     bae   |
|     15     |      4     |     e     |
```
Первые 5 символов - символы алфавита. Далее идем по входной строке, 
храня фразу `X` и считывя символ `y`. Если фраза `Xy` уже есть в словаре, 
то присваиваем`X := Xy` и идем дальне. Иначе записываем в `Output` код фразы `X`
в словаре и добавляем с словарь новую фразу `Xy`, присваиваем `X := y`, считываем новый символ.

#### Деодирование алгоритмом Лемпеля — Зива — Велча

Алгоритм получает выходной поток кодов от алгоритма сжатия и использует его для точного восстановления 
входного потока. Одной из причин эффективности LZW-алгоритма является то, что он не нуждается в хранении 
таблицы строк, полученной при сжатии. Таблица может быть точно восстановлена при распаковке на основе выходного 
потока алгоритма сжатия.

**Пример**  
Нужно декодировать последовательность чисел `0 1 0 2 5 0 3 9 8 6 4` в алфавите `A = {a, b, c, d, e}`
```
|   Index    |    Input   |   Output  -|   Entry   |
|------------|------------|------------|-----------|
|     0      |      -     |      -     |     a     |
|     1      |      -     |      -     |     b     |
|     2      |      -     |      -     |     c     |
|     3      |      -     |      -     |     d     |
|     4      |      -     |      -     |     e     |
|     5      |      0     |      a     |     ab    |
|     6      |      1     |      b     |     ba    |
|     7      |      0     |      a     |     ac    |
|     8      |      2     |      c     |     ca    |
|     9      |      5     |      ab    |     aba   |
|     10     |      0     |      a     |     ad    |
|     11     |      3     |      d     |     da    |
|     12     |      9     |      aba   |     abac  |
|     13     |      8     |      ca    |     cab   |
|     14     |      6     |      ba    |     bae   |
|     15     |      4     |      e     |     e     |
```
Как и при сжатии, первые 5 символов - символы алфавита. Далее последовательно 
считываем коды из входной последовательности и записываем в `Entry` и в `Output` фразу, 
соответствующую текущему коду. При каждом чтении (кроме первого) дописываем первый символ 
текущей фразы к последней записи в `Entry` (так на втором шаге (индекс 6) читаем новый код 1, ему соответствует символ `b`, 
тогда по индексу 5 в столбце `Entry` `a -> ab`, по индексу 6 - `b -> ba`, 7 - `a -> ac`).

## Выбор алгоритма

В текущей реализации используется прямой алгоритм и улучшенный обратный алгоритм преобразования Барроуза — Уилера, 
поскольку (пока) длина входных данных меньше размера алфавита.
