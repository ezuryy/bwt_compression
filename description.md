# Описание программы

## Краткое описание логики. 

### BWT

### `pair<string, size_t> BWT_encode(const string& input)`

Реализация прямого преобразования Барроуза — Уилера.  
Пусть `N` - длина входного слова. Составляем вектор строк, содержащий все его циклические сдвиги. 
Для этого пройдемся в цикле за `O(N)` по входной строке. Затем сортируем содержимое вектора в лексикографическом порядке 
с помощью `std::sort()` за `O(NlogN)`. За `O(N)` находим в отсортированном векторе исходную строку, далее 
за `O(N)` получаем последний столбец в матрице циклических сдвигов. Это и есть преобразованная строка. Итого затраты по времени `O(NlogN)`.  

Для хранения матрицы циклических сдвигов используется вектор длины `N`, содержащий строки длины `N` => используем `О(N^2)` памяти. 

### `string BWT_decode(const size_t& k, const string& last)`

Реализация обратного преобразования Барроуза — Уилера.  
Пусть `N` - длина входного слова. Составляем вектор символов, содержащихся в искомом слове за `O(N)`, 
сортируем в лексикографическом порядке за `O(NlogN)`, таким образом получаем первый столбец в отсортированной 
мартице циклических сдвигов. Используем хэш-таблицу для хранения пар `символ -> наименьший индекс, по 
которому находится этот символ в отсортированном векторе символов`. Для ее создания в цикле длины `N` проверяем, есть ли 
этот символ в хэш-таблице (за константу), и если его нет, то добавляем (за константу). Далее создаем вектор с 
индексами-предшественниками, проходясь по каждому из `N` символов входного слова и за константу обращаясь к хэш-таблице. 
Снова проходимся по входному слову, внутри цикла за константу обращаемся к строке и вектору по индексу, таким 
образом воспроизводим исходное слово. Осталось только развернуть его за `O(N / 2)`. Итого временная сложность `O(NlogN)`.  

Длина любого объекта, используемого в этой функции, не превышает `N` => сложность по памяти `O(N)`.

### LZW

### `vector<size_t> LZW_encode(const string& input)`  

Реализация кодирования алгоритмом Лемпеля — Зива — Велча.  
Используем хэш-таблицу для хранения пар `строка -> ее код`, то есть словаря. Для хранения кодов используем вектор. 
Сначала за константу `ALPHABET_SIZE` добавляем в словарь все символы алфавита. 
Т.к. в хэш-таблице поиск и добавление происходят за константу, как и вставка в конец вектора, то операции 
внутри цикла, выполняющего сжатие, производятся за константу. Цикл содержит `N` итераций => сложность этой функции `O(N)`.  

Размер словаря не превышает константу `MAX_CODE`, в каждом элементе хэш-таблицы хранится строка, длина которой не 
превышает `N`, а длина выходного вектора не больше длины слова `N` => затраты по памяти составляют `O(N)`.

### `string LZW_decode(const vector<size_t>& input)`  

Реализация декодирования алгоритмом Лемпеля — Зива — Велча.  
Теперь для хранения словаря удобно использовать вектор, т.к. обращение по индексу за константу и добавление 
в конец за константу. За `ALPHABET_SIZE` шагов добавляем в словарь все символы алфавита. За `O(N)` проходимся по 
входной строке, получая по значению кодов символы в исходной строке. Сложность этой функции `O(N)`.  

Количество слов в словаре не больше, чем `MAX_CODE`, длина любого элемента вектора не больше `N` => затраты по памяти составляют `O(N)`.

### Работа с файлами

### `ShowOptions()`  

Отрабатывает при неправильном вводе и говорит пользователю, как пользоваться программой.

### `void OpenOutputBFile(const string& name)` 

Открывает файл для записи сжатого текста. 

### `void OpenInputBFile(const string& name)`

Открывает файл для считывания сжатого текста.

### `void CloseOutputBFile()`

Закрывает файл для записи сжатого текста.

### `void CloseInputBFile()`

Закрывает файл, содержащий сжатый текст.

### `void CloseInputBFile()`

Закрывает файл, содержащий сжатый текст.

### `void WriteBits(size_t code, int count)`

Побитово записывает код. Цикл повторяется `BITS - 1` раз. Внутри цикла операции выполняются за константу.  

### `size_t ReadBits(int bit_count)`

Посимвольно считывает код. Цикл повторяется `BITS - 1` раз. Внутри цикла операции выполняются за константу.  

### `size_t Filesize(const string& filename)`

Открывает файл, возвращает количество битов в нем.  

### `size_t CompressionRatio(const string& input_filename, сonst string& output_filename)`

Выводит размер входного и выходного файла, возвращает коэффициент сжатия в процентах.

### `void CompressFile(const std::string& input_filename, const std::string& output_filename)`

Операция сжатия.  
Открывает файл, который нужно сжать, открывает файл, в который нужно записать результат компрессии. Пусть `N` - 
длина входной строки. За `O(N)` посимвольно считываем строку из файла, применяем BWT преобразование за `O(NlogN)`, 
применяем алгоритм LZW для компрессии за `O(N)`. Количество кодов не превосходит длины исходного сообщения `N`, поэтому 
запись в выходной файл производится за `O((BITS - 1) * N)` опрераций, то есть за `O(N)`. Закрываем файлы. Затраты по 
времени составляют `O(NlogN)`.  

Затраты по памяти составляют `O(N)`, т.к. используется две строки длинной порядка `N` и вектор, длина которого также 
не превышает `N`. Но т.к. при вызове `BWT_encode()` используется `O(N^2)` памяти, то общие затраты по памяти составят `O(N^2)`. 

### `void ExpandFile(const std::string& input_filename, const std::string& output_filename)`

Операция распаковки.  
Открывает файл, который нужно распаковать, открывает файл, в который нужно записать исходное сообщение. Пусть `N` -
длина входной строки. Сначала считываем `k` - индекс искомой строки в таблице циклических сдвигов. Затем за `O((BITS - 1) * N)` 
считываем сжатое сообщение, внутри цикла за константу добавляем полученные коды в ветор кодов. За `O(N)` получаем 
декодорованное алгоритмом LZW сообщение, применяем обратное преобразование BWT за `O(NlogN)`, записываем результат 
декомпрессии в выходной файл. Затраты по времени составляют `O(NlogN)`.  

Затраты по памяти составляют `O(N)`, т.к. используется две строки длинной порядка `N` и вектор, длина которого также
не превышает `N`.

## Использованные структуры данных

`pair<string, size_t> BWT_encode(const string& input)`:  
* Для хранения циклических сдвигов используется вектор, т.к. для него добавление в конец производится за константу, 
сортировка имеет сложность `NlogN`.  

`string BWT_decode(const size_t& k, const string& last)`:  
* Для хранения первого столбца матрицы циклических сдвигов используется вектор, т.к. для него добавление в конец производится за константу,
  сортировка имеет сложность `NlogN`.  
* Для хранения соответствия символов индексам их первого вхождения в сортированную 
строку используется хэш-таблица (добавление и доступ за константу).
* Для хранения переходов используется вектор (добавление и доступ за константу).  

`vector<size_t> LZW_encode(const string& input)`:  
* Для хранения пар `строка -> ее код` используется хэш-таблица, т.к. нужно за константу проверять наличие фразы в 
словаре, а также за константу добавлять новые фразы с кодами.
* Для хранения итоговой последовательности кодов используется вектор (т.к. добавление в конец за константу).

`string LZW_decode(const vector<size_t>& input)`:  
* Для хранения словаря удобно использовать вектор, т.к. обращение по индексу за константу и добавление
  в конец за константу.

При работе с файлами используются те же структуры данных, что и при работе алгоритмов и преобразований.

## Оценка сложности 

`pair<string, size_t> BWT_encode(const string& input)`: `O(NlogN)`  
`string BWT_decode(const size_t& k, const string& last)`: `O(NlogN)`  
`vector<size_t> LZW_encode(const string& input)`: `O(N)`  
`string LZW_decode(const vector<size_t>& input)`: `O(N)`  
`ShowOptions()`: `O(1)`  
`void OpenOutputBFile(const string& name)`: `O(1)`  
`void OpenInputBFile(const string& name)`: `O(1)`  
`void CloseOutputBFile()`: `O(1)`  
`void CloseInputBFile()`: `O(1)`  
`void WriteBits(size_t code, int count)`: `O(1)`  
`size_t ReadBits(int bit_count)`: `O(1)`  
`size_t Filesize(const string& filename)`: `O(1)`  
`size_t CompressionRatio(const string& input_filename, сonst string& output_filename)`: `O(NlogN)`  
`void ExpandFile(const std::string& input_filename, const std::string& output_filename)`: `O(NlogN)`  

## Оценка использования памяти

`pair<string, size_t> BWT_encode(const string& input)`: `O(N^2)`   
`string BWT_decode(const size_t& k, const string& last)`: `O(N)`  
`vector<size_t> LZW_encode(const string& input)`: `O(N)`  
`string LZW_decode(const vector<size_t>& input)`: `O(N)`  
`ShowOptions()`: `O(1)`  
`void OpenOutputBFile(const string& name)`: `O(1)`  
`void OpenInputBFile(const string& name)`: `O(1)`  
`void CloseOutputBFile()`: `O(1)`  
`void CloseInputBFile()`: `O(1)`  
`void WriteBits(size_t code, int count)`: `O(1)`  
`size_t ReadBits(int bit_count)`: `O(1)`  
`size_t Filesize(const string& filename)`: `O(1)`  
`size_t CompressionRatio(const string& input_filename, сonst string& output_filename)`: `O(N^2)`  
`void ExpandFile(const std::string& input_filename, const std::string& output_filename)`: `O(N)`  
