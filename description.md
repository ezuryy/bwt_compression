# Описание программы

## Краткое описание логики. 

### BWT

### `pair<ustring, int> BWT_encode(const ustring& input)`

Реализация прямого преобразования Барроуза — Уилера.  
Пусть `N` - длина входного слова. Составляем вектор строк, содержащий все его циклические сдвиги. 
Для этого пройдемся в цикле за `O(N)` по входной строке. Затем сортируем содержимое вектора в лексикографическом порядке 
с помощью `std::sort()` за `O(NlogN)`. За `O(N)` находим в отсортированном векторе исходную строку, далее 
за `O(N)` получаем последний столбец в матрице циклических сдвигов. Это и есть преобразованная строка. Итого затраты по времени `O(NlogN)`.  

Для хранения матрицы циклических сдвигов используется вектор длины `N`, содержащий строки длины `N` => используем `О(N^2)` памяти. 

### `ustring BWT_decode(const size_t& k, const ustring& last, const bool& use_optimized)`

Реализация обратного преобразования Барроуза — Уилера.  
Пусть `N` - длина входного слова. Составляем вектор символов, содержащихся в искомом слове за `O(N)`, 
сортируем в лексикографическом порядке за `O(NlogN)`, таким образом получаем первый столбец в отсортированной 
мартице циклических сдвигов. Используем хэш-таблицу для хранения пар `символ -> наименьший индекс, по 
которому находится этот символ в отсортированном векторе символов`. Для ее создания в цикле длины `N` проверяем, есть ли 
этот символ в хэш-таблице (за константу), и если его нет, то добавляем (за константу). Далее создаем вектор с 
индексами-предшественниками, проходясь по каждому из `N` символов входного слова и за константу обращаясь к хэш-таблице. 
Снова проходимся по входному слову, внутри цикла за константу обращаемся к строке и вектору по индексу, таким 
образом воспроизводим исходное слово. Осталось только развернуть его за `O(N / 2)`. Итого временная сложность `O(NlogN)`.  

Длина любого объекта, используемого в этой функции, не превышает `N` => сложность по памяти `O(N)`.

### Suffix tree for BWT

### `void addSuffix(const int& suffix_begin_index)` и `void createTree(ustring& input)`

Добавление в суффиксное дерево алгоритмом Укконена.  
Идём по дереву и сверяем символы суффикса с имеющимися. Когда находим несовпадение, есть два случая:
1. Из узла нет ребра, нужного для продолжения (нет начального символа, сопадающего с начальным символом оставшейся
части суффикса). Тогда мы из данного узла пускаем ребро, помеченное оставшейся частью суффикса
2. Несовпадение пришлось на ребро. Тогда нам нужно в месте несовпадения создать узел. Таким образом, мы фактически
делим ребро этим узлом. Чтобы соблюсти изначальное состояние, мы в данный узел направляем часть ребра до несовпадения, 
а из него пускаем оставшуюся часть ребра. Также, мы добавляем новое исходящее ребро, помеченное оставшейся частью
суффикса

Спускаемся в дерево по указателям, хранимым в каждом узле. Поэтому фактически проходимся по имеющимся ветвям за 
константу (ищем в корне подходящее ребро - константа т.к. мощность алфавита константа, когда добавили в текущее ребро 
переходим по ссылке в следующее, т.к. вершин не может быть создано больше, чем их есть, то амортизационно на каждой 
фазе будет создано `O(1)` вершин). Итого, суффикс добавляется за константу, а дерево создается за `O(N)`.

В течение работы алгоритма создается не более `O(N)` вершин по лемме о размере суффиксного дерева для строки. В каждой 
вершине хранится список ребер (их число не больше можности алфавита - константа), в каждом ребре хранятся индексы 
начала и конца ребра, индекс суффикса в префиксном дереве (если это ребро ведет к листу) и указатель на вершину для перехода. 
Таким образом, кол-во памяти, необходимой для хранения одной вершины - константа, тогда для хранения дерева нужно `O(N)` памяти.  

### `~AdoptedSuffixTree()`

Удаление представляет из себя алгоритм обхода в ширину. Для его реализации используется очередь. 
Алгоритм запускается с корня. Выполняется за `O(N)`

### `pair<ustring, int> BWT_encode_optimized()`

Получение преобразованной строки представляет из себя алгоритм обхода в глубину. Для его реализации используется стек.
Алгоритм запускается с корня. Выполняется за `O(N)`

### LZW

### `vector<size_t> LZW_encode(const ustring& input)`  

Реализация кодирования алгоритмом Лемпеля — Зива — Велча.  
Используем хэш-таблицу для хранения пар `строка -> ее код`, то есть словаря. Для хранения кодов используем вектор. 
Сначала за константу `ALPHABET_SIZE` добавляем в словарь все символы алфавита. 
Т.к. в хэш-таблице поиск и добавление происходят за константу, как и вставка в конец вектора, то операции 
внутри цикла, выполняющего сжатие, производятся за константу. Цикл содержит `N` итераций => сложность этой функции `O(N)`.  

Размер словаря не превышает константу `MAX_CODE`, в каждом элементе хэш-таблицы хранится строка, длина которой не 
превышает `N`, а длина выходного вектора не больше длины слова `N` => затраты по памяти составляют `O(N)`.

### `ustring LZW_decode(const vector<size_t>& input)`  

Реализация декодирования алгоритмом Лемпеля — Зива — Велча.  
Теперь для хранения словаря удобно использовать вектор, т.к. обращение по индексу за константу и добавление 
в конец за константу. За `ALPHABET_SIZE` шагов добавляем в словарь все символы алфавита. За `O(N)` проходимся по 
входной строке, получая по значению кодов символы в исходной строке. Сложность этой функции `O(N)`.  

Количество слов в словаре не больше, чем `MAX_CODE`, длина любого элемента вектора не больше `N` => затраты по памяти составляют `O(N)`.

### Работа с файлами

### `ShowOptions()`  

Отрабатывает при неправильном вводе и говорит пользователю, как пользоваться программой.

### `ofstream OpenOutputBFile(const string& name)` 

Открывает файл для записи сжатого текста. 

### `ifstream OpenInputBFile(const string& name)`

Открывает файл для считывания сжатого текста.

### `void CloseOutputBFile(ofstream& bfile_out)`

Закрывает файл для записи сжатого текста.

### `void CloseInputBFile(ifstream& bfile_in)`

Закрывает файл, содержащий сжатый текст.

### `void WriteBits(ofstream& bfile_out, size_t code, int count)`

Побитово записывает код. Цикл повторяется `BITS - 1` раз. Внутри цикла операции выполняются за константу.  

### `size_t ReadBits(ifstream& bfile_in, int bit_count)`

Посимвольно считывает код. Цикл повторяется `BITS - 1` раз. Внутри цикла операции выполняются за константу.  

### `size_t Filesize(const string& filename)`

Открывает файл, возвращает количество битов в нем.  

### `size_t CompressionRatio(const string& input_filename, сonst string& output_filename)`

Выводит размер входного и выходного файла, возвращает коэффициент сжатия в процентах.

### `void CompressFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`

Операция сжатия.  
Открывает файл, который нужно сжать, открывает файл, в который нужно записать результат компрессии. Пусть `N` - 
длина входной строки. За `O(N)` посимвольно считываем строку из файла, применяем BWT преобразование за `O(NlogN)`, 
применяем алгоритм LZW для компрессии за `O(N)`. Количество кодов не превосходит длины исходного сообщения `N`, поэтому 
запись в выходной файл производится за `O((BITS - 1) * N)` опрераций, то есть за `O(N)`. Закрываем файлы. Затраты по 
времени составляют `O(NlogN)`.  

Затраты по памяти составляют `O(N)`, т.к. используется две строки длинной порядка `N` и вектор, длина которого также 
не превышает `N`. Но т.к. при вызове `BWT_encode()` используется `O(N^2)` памяти, то общие затраты по памяти составят `O(N^2)`. 

### `void ExpandFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`

Операция распаковки.  
Открывает файл, который нужно распаковать, открывает файл, в который нужно записать исходное сообщение. Пусть `N` -
длина входной строки. Сначала считываем `k` - индекс искомой строки в таблице циклических сдвигов. Затем за `O((BITS - 1) * N)` 
считываем сжатое сообщение, внутри цикла за константу добавляем полученные коды в ветор кодов. За `O(N)` получаем 
декодорованное алгоритмом LZW сообщение, применяем обратное преобразование BWT за `O(NlogN)`, записываем результат 
декомпрессии в выходной файл. Затраты по времени составляют `O(NlogN)`.  

Затраты по памяти составляют `O(N)`, т.к. используется две строки длинной порядка `N` и вектор, длина которого также
не превышает `N`.

## Использованные структуры данных

`pair<ustring, int> BWT_encode(const ustring& input)`:  
* Для хранения циклических сдвигов используется вектор, т.к. для него добавление в конец производится за константу, 
сортировка имеет сложность `NlogN`.  

`string BWT_decode(const size_t& k, const string& last)`:  
* Для хранения первого столбца матрицы циклических сдвигов используется вектор, т.к. для него добавление в конец производится за константу,
  сортировка имеет сложность `NlogN`.  
* Для хранения соответствия символов индексам их первого вхождения в сортированную 
строку используется хэш-таблица (добавление и доступ за константу).
* Для хранения переходов используется вектор (добавление и доступ за константу).  

`vector<size_t> LZW_encode(const ustring& input)`:  
* Для хранения пар `строка -> ее код` используется хэш-таблица, т.к. нужно за константу проверять наличие фразы в 
словаре, а также за константу добавлять новые фразы с кодами.
* Для хранения итоговой последовательности кодов используется вектор (т.к. добавление в конец за константу).

`string LZW_decode(const vector<size_t>& input)`:  
* Для хранения словаря удобно использовать вектор, т.к. обращение по индексу за константу и добавление
  в конец за константу.

`AdoptedSuffixTree`:
В каждой вершине хранится список ребер (красно-черное дерево, потому что нам нужно хранить отсортированные по значению символов ребра), в 
каждом ребре хранятся индексы начала и конца ребра, индекс суффикса в префиксном дереве (если это ребро ведет к листу) 
и указатель на вершину для перехода.

При работе с файлами используются те же структуры данных, что и при работе алгоритмов и преобразований.

## Оценка сложности 

`pair<ustring, int> BWT_encode(const ustring& input)`: `O(NlogN)`  
`ustring BWT_decode(const size_t& k, const ustring& last, const bool& use_optimized)`: `O(NlogN)`  
`vector<size_t> LZW_encode(const ustring& input)`: `O(N)`  
`ustring LZW_decode(const vector<size_t>& input)`: `O(N)`  
`void addSuffix(const int& suffix_begin_index)` и `void createTree(ustring& input)`: `O(N)`  
`~AdoptedSuffixTree()`: `O(N)`  
`pair<ustring, int> BWT_encode_optimized()`: `O(N)`
`ShowOptions()`: `O(1)`  
`ofstream OpenOutputBFile(const string& name)`: `O(1)`  
`ifstream OpenInputBFile(const string& name)`: `O(1)`  
`void CloseOutputBFile(ofstream& bfile_out)`: `O(1)`  
`void CloseInputBFile(ifstream& bfile_in)`: `O(1)`  
`void WriteBits(ofstream& bfile_out, size_t code, int count)`: `O(1)`  
`size_t ReadBits(ifstream& bfile_in, int bit_count)`: `O(1)`  
`size_t Filesize(const string& filename)`: `O(1)`  
`size_t CompressionRatio(const string& input_filename, const string& output_filename)` : `O(1)`  
`void CompressFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`: `O(NlogN)`  
`void ExpandFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`: `O(NlogN)`  

## Оценка использования памяти

`pair<string, size_t> BWT_encode(const string& input)`: `O(N^2)`   
`ustring BWT_decode(const size_t& k, const ustring& last, const bool& use_optimized)`: `O(N)`  
`vector<size_t> LZW_encode(const string& input)`: `O(N)`  
`ustring LZW_decode(const vector<size_t>& input)`: `O(N)`  
`void addSuffix(const int& suffix_begin_index)` и `void createTree(ustring& input)`: `O(N)`
`~AdoptedSuffixTree()`: `O(1)`  
`pair<ustring, int> BWT_encode_optimized()`: `O(1)`  
`ShowOptions()`: `O(1)`  
`ofstream OpenOutputBFile(const string& name)`: `O(1)`  
`ifstream OpenInputBFile(const string& name)`: `O(1)`  
`void CloseOutputBFile(ofstream& bfile_out)`: `O(1)`  
`void CloseInputBFile(ifstream& bfile_in)`: `O(1)`  
`void WriteBits(ofstream& bfile_out, size_t code, int count)`: `O(1)`  
`size_t ReadBits(ifstream& bfile_in, int bit_count)`: `O(1)`  
`size_t Filesize(const string& filename)`: `O(1)`  
`size_t CompressionRatio(const string& input_filename, const string& output_filename)` : `O(1)`  
`void CompressFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`: `O(N^2)`  
`void ExpandFile(const std::string& input_filename, const std::string& output_filename, const bool& use_optimized)`: `O(N)`  
